using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Diagnostics;

namespace MageeSoft.PDX.CE.SourceGenerator;

public static class ModelGenerationHelper
{
    public const string AttributeName = "MageeSoft.PDX.CE.GameStateDocumentAttribute";

    public const string Attribute = """
                                    // <auto-generated/>
                                    using System;

                                    namespace MageeSoft.PDX.CE
                                    {
                                        /// <summary>
                                        /// Marks a class for source generation based on a specific Paradox gamestate schema file.
                                        /// </summary>
                                        [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
                                        public class GameStateDocumentAttribute : Attribute
                                        {
                                            /// <summary>
                                            /// Gets the schema file name to use for generating this class.
                                            /// </summary>
                                            public string SchemaFileName { get; }

                                            /// <summary>
                                            /// Creates a new instance of the GameStateDocumentAttribute.
                                            /// </summary>
                                            /// <param name="schemaFileName">The name of the schema file to use for generating this class.</param>
                                            public GameStateDocumentAttribute(string schemaFileName)
                                            {
                                                SchemaFileName = schemaFileName;
                                            }
                                        }
                                    }
                                    """;
}

[Generator]
public class IncrementalGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 0. Create marker attribute to use on classes that need to be generated based on a schema file
        // 1. only generate models if the option is enabled
        // 2. find all classes with the GameStateDocumentAttribute
        // 3. extract the schemaFileName value from the attribute 
        // 4. match the schemaFileName to the name of provided AdditionalFiles
        // 5. parse the schema file and generate the model code for the relevant class based on the class attribute

        // 0. Create marker attribute to use on classes that need to be generated based on a schema file
        context.RegisterPostInitializationOutput(static ctx => ctx.AddSource(
                hintName: "GameStateDocumentAttribute.g.cs",
                source: ModelGenerationHelper.Attribute
            )
        );

        // 2. find all classes with the GameStateDocumentAttribute
        IncrementalValuesProvider<ClassSchemaPair?> classDeclarations = context.SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: ModelGenerationHelper.AttributeName,
                predicate: static (syntaxNode, token) => syntaxNode is ClassDeclarationSyntax,
                transform: static (syntaxContext, token) =>
                {
                    if (syntaxContext.TargetNode is not ClassDeclarationSyntax classDeclaration)
                    {
                        return null;
                    }

                    AttributeData attribute = syntaxContext.Attributes.First(a => a.AttributeClass!.Name == "GameStateDocumentAttribute");
                    var schemaFileName = attribute.ConstructorArguments[0].Value?.ToString();

                    return new ClassSchemaPair
                    {
                        ClassDeclaration = classDeclaration,
                        SchemaFileName = schemaFileName
                    };
                }
            )
            .Where(classSchemaPair => classSchemaPair != null);
        
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());
        var additionalTexts = context.AdditionalTextsProvider.Where(static additionalText => additionalText.Path.EndsWith(".csf", StringComparison.OrdinalIgnoreCase));
        var result = compilationAndClasses.Combine(additionalTexts.Collect());

        context.RegisterSourceOutput(result, ExecuteSchemaInferenceToClasses);
    }

    void ExecuteSchemaInferenceToClasses(
        SourceProductionContext sourceProductionContext, 
        ((Compilation Left, ImmutableArray<ClassSchemaPair?> Right) Left, ImmutableArray<AdditionalText> Right) valueTuple)
    {
        foreach (ClassSchemaPair classDeclaration in valueTuple.Left.Right)
        {
            foreach (AdditionalText additionalText in valueTuple.Right)
            {
                if (Path.GetFileName(additionalText.Path).Equals(classDeclaration!.SchemaFileName!, StringComparison.OrdinalIgnoreCase))
                {
                   /* Tasks
                   1. Parse the sav file using the Parser.Parse(text)
                   2. Schema inference to generate all schemas recursively from the root SaveObject
                   4  Generate the 'ClassName.g.cs' associated with partial class with the GameStateDocumentAttribute(schemaFileName)

                   Outcome: Should be able to recursively Load all data into C# objects into a Root Model (Gamestate) and also potentially serialize it back to a sav file
                   */
                   
                   
                   // 1. Parse the sav file using the Parser.Parse(text)
                   SaveObject root = Parser.Parse(additionalText.GetText()!.ToString());
                   
                   // 2. Schema inference to generate all schemas recursively from the root SaveObject
                   
                   
                   // 3. Generate the 'ClassName.g.cs' associated with partial class with the GameStateDocumentAttribute(schemaFileName)
                   sourceProductionContext.AddSource(
                       hintName: $"{classDeclaration.ClassDeclaration!.Identifier}.g.cs",
                       source: "// TODO: Replace with source code of all generated classes using results from Schema inference"
                   );
                   
                }
            }
        }
    }



    public class Schema
    {
        public string Name { get; set; }
        public string? Comment { get; set; }
        public List<SchemaProperty> Properties { get; set; } = new List<SchemaProperty>();
        
        /// <summary>
        /// Recursively builds up a schema from a SaveObject and all its children
        /// </summary>
        /// <param name="saveObject"></param>
        /// <param name="className"></param>
        /// <returns></returns>
        public static List<Schema> SchemaInference(SaveObject saveObject, string key)
        {
            return [];
        }
    }
    
    public class SchemaProperty
    {
        // The original name of the key
        public string KeyName { get; set; }
        
        // The C# PascalCase name for the property (derived from the key name)
        public string PropertyName { get; set; }
        
        // The C# <summary></summary> comment for the property
        public string? SummaryComment { get; set; }
        
        // The C# type of the property
        public string Type { get; set; }
        public SaveType SaveType { get; set; }
    }

    public class ClassSchemaPair
    {
        public ClassDeclarationSyntax? ClassDeclaration { get; set; }
        public string? SchemaFileName { get; set; }
    }
}