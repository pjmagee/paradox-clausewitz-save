using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using System.Text.RegularExpressions;
using System.Globalization;

namespace MageeSoft.PDX.CE.SourceGenerator;

/// <summary>
/// Helper class for generating models from PDX save files
/// </summary>
public static class ModelsGenerator
{
    private const string Namespace = "MageeSoft.PDX.CE.Models";

    // Simple types frequently referenced - we use OrdinalIgnoreCase for comparisons
    private readonly static HashSet<string> SimpleTypes = new(StringComparer.OrdinalIgnoreCase)
    {
        "string", "int", "long", "float", "double", "bool", "DateTime", "Guid",
        "System.String", "System.Int32", "System.Int64", "System.Single",
        "System.Double", "System.Boolean", "System.DateTime", "System.Guid"
    };

    public static void GenerateModels(SourceProductionContext context, AdditionalText file, IEnumerable<SaveObjectAnalysis> analyses)
    {
        try
        {
            // Add explicit diagnostic to log which file is being processed
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor("PDXSG100", "Processing File", $"Processing file: {file.Path}", "StellarisModelsGenerator", DiagnosticSeverity.Info, true),
                Location.None));

            var analysisList = analyses?.ToList() ?? new List<SaveObjectAnalysis>();

            // Report number of analyses found
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor("PDXSG101", "Analysis Count", $"Found {analysisList.Count} analyses for file {file.Path}", "StellarisModelsGenerator", DiagnosticSeverity.Info, true),
                Location.None));

            // Report analyzer diagnostics first
            foreach (var analysis in analysisList)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor("PDXSG102", "Analysis Root Name", $"Analysis root name: {analysis.RootName}", "StellarisModelsGenerator", DiagnosticSeverity.Info, true),
                    Location.None));

                foreach (var diagInfo in analysis.Diagnostics)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(diagInfo.Id, diagInfo.Title, diagInfo.Message, "StellarisAnalyzer", diagInfo.Severity, true),
                        Location.None));
                }

                // Report explicit errors caught by the analyzer
                if (analysis.Error != null && !analysis.Diagnostics.Any(d => d.Id == "PDXSA003"))
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                       new DiagnosticDescriptor("PDXSG005", "Analyzer Phase Error", $"Analyzer failed for {analysis.RootName}: {analysis.Error.GetType().Name} - {analysis.Error.Message} {analysis.Error.StackTrace}", "StellarisModelsGenerator", DiagnosticSeverity.Error, true),
                       Location.None));
                }
            }

            if (!analysisList.Any())
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor("PDXSG004", "Analyzer Input Empty", $"No analysis results received for {Path.GetFileName(file.Path)}. Skipping generation.", "StellarisModelsGenerator", DiagnosticSeverity.Warning, true),
                    Location.None));
                return;
            }

            // Determine the root model name from the file name
            string fileName = Path.GetFileName(file.Path);
            string rootModelName = DetermineRootModelName(fileName);

            // Group analyses by root file type - using dynamically determined root name
            var analysisGroups = analysisList.Where(a => a.Error == null)
                .GroupBy(_ => rootModelName)
                .ToDictionary(g => g.Key, g => g.ToList());

            // Generate one file for each group of analyses
            foreach (var group in analysisGroups)
            {
                string rootName = group.Key;
                var analysesInGroup = group.Value;

                // Prepare StringBuilder for the entire file content
                var fileContentBuilder = new StringBuilder();

                // Add standard usings and attribute definitions
                fileContentBuilder.AppendLine("// <auto-generated/>");
                fileContentBuilder.AppendLine("#nullable enable");
                fileContentBuilder.AppendLine("using System;");
                fileContentBuilder.AppendLine("using System.Collections.Generic;");
                fileContentBuilder.AppendLine("using System.Linq;");
                fileContentBuilder.AppendLine("using System.Globalization;");
                fileContentBuilder.AppendLine("using MageeSoft.PDX.CE;");
                fileContentBuilder.AppendLine();

                // Add the namespace block for this root type
                fileContentBuilder.AppendLine($"namespace {Namespace}");
                fileContentBuilder.AppendLine("{");

                // Dictionary to track already generated class names to merge definitions
                Dictionary<string, HashSet<string>> generatedClasses = new Dictionary<string, HashSet<string>>();

                // Also track fully qualified names to avoid duplicate definitions
                HashSet<string> generatedFullNames = new HashSet<string>();

                // Process all top-level classes from all analyses in this group
                foreach (var analysis in analysesInGroup)
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor("PDXSG007", "Generating Root Info",
                            $"Analysis for {analysis.RootName} found {analysis.ClassDefinitions.Count} top-level class definitions.",
                            "StellarisModelsGenerator", DiagnosticSeverity.Info, true),
                        Location.None));

                    // Process each top-level class definition
                    foreach (var topLevelClassDef in analysis.ClassDefinitions.Values)
                    {
                        // Skip null/empty class names
                        if (string.IsNullOrEmpty(topLevelClassDef?.Name))
                        {
                            context.ReportDiagnostic(Diagnostic.Create(
                                new DiagnosticDescriptor("PDXSG009", "Invalid Class Definition",
                                    $"Skipping generation for a class definition with null or empty name from analysis of {analysis.RootName}.",
                                    "StellarisModelsGenerator", DiagnosticSeverity.Warning, true),
                                Location.None));
                            continue;
                        }

                        // Skip primitive types and C# reserved names
                        if (IsReservedTypeName(topLevelClassDef.Name))
                        {
                            context.ReportDiagnostic(Diagnostic.Create(
                                new DiagnosticDescriptor("PDXSG010", "Skipping Reserved Type",
                                    $"Skipping generation for reserved type name {topLevelClassDef.Name}.",
                                    "StellarisModelsGenerator", DiagnosticSeverity.Warning, true),
                                Location.None));
                            continue;
                        }

                        // Check if we've already generated this class to avoid duplicates
                        string fullClassName = topLevelClassDef.FullName;
                        if (generatedFullNames.Contains(fullClassName))
                        {
                            context.ReportDiagnostic(Diagnostic.Create(
                                new DiagnosticDescriptor("PDXSG011", "Skipping Duplicate Class",
                                    $"Skipping duplicate class definition for {fullClassName}.",
                                    "StellarisModelsGenerator", DiagnosticSeverity.Info, true),
                                Location.None));
                            continue;
                        }

                        // Add class to output
                        GenerateClassSourceRecursive(topLevelClassDef, fileContentBuilder, 1, generatedFullNames);

                        // Track that we generated this class
                        generatedFullNames.Add(fullClassName);

                        if (!generatedClasses.TryGetValue(topLevelClassDef.Name, out var paths))
                        {
                            paths = new HashSet<string>();
                            generatedClasses[topLevelClassDef.Name] = paths;
                        }
                        if (!string.IsNullOrEmpty(topLevelClassDef.OriginalPath))
                        {
                            paths.Add(topLevelClassDef.OriginalPath);
                        }
                    }
                }

                // Close namespace
                fileContentBuilder.AppendLine("}");
                fileContentBuilder.AppendLine(); // Trailing newline

                // Add the source file for this root type
                context.AddSource($"{rootName}.g.cs", SourceText.From(fileContentBuilder.ToString(), Encoding.UTF8));

                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor("PDXSG008", "Generated File",
                        $"Generated model file {rootName}.g.cs containing {generatedClasses.Count} top-level classes.",
                        "StellarisModelsGenerator", DiagnosticSeverity.Info, true),
                    Location.None));
            }
        }
        catch (Exception ex)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor("PDXSG001", "Generator Exception", $"Generator failed unexpectedly: {ex.GetType().Name} - {ex.Message} {ex.StackTrace}", "StellarisModelsGenerator", DiagnosticSeverity.Error, true),
                Location.None));
        }
    }

    /// <summary>
    /// Determines the root model name based on the file name.
    /// This replaces the hardcoded GetModelRootName function with a more flexible approach.
    /// </summary>
    /// <param name="fileName">The name of the file being processed</param>
    /// <returns>The appropriate root model name</returns>
    private static string DetermineRootModelName(string fileName)
    {
        // Extract base name without extension
        string baseName = Path.GetFileNameWithoutExtension(fileName).ToLowerInvariant();
        
        // Apply naming rules based on file name pattern
        // For future extensibility, this could be moved to a configuration file
        if (baseName.EndsWith("meta", StringComparison.OrdinalIgnoreCase))
        {
            return "Meta";
        }
        
        // Default to Gamestate for any other file type
        return "Gamestate";
    }

    /// <summary>
    /// Recursively generates the C# source code for a class definition, including its properties,
    /// binder method, and any nested classes. Appends to the provided StringBuilder.
    /// </summary>
    private static void GenerateClassSourceRecursive(ClassDefinition classDef, StringBuilder sb, int indentLevel, HashSet<string> generatedFullNames)
    {
        string indent = new string(' ', indentLevel * 4);

        // Class comment for the C# class
        sb.AppendLine($"{indent}/// <summary>");

        // Add original path info if available
        if (!string.IsNullOrEmpty(classDef.OriginalPath))
        {
            sb.AppendLine($"{indent}/// Generated from PDX save path: {classDef.OriginalPath}");
        }

        sb.AppendLine($"{indent}/// </summary>");

        // Generate the class definition line
        sb.AppendLine($"{indent}public class {classDef.Name}");
        sb.AppendLine($"{indent}{{");

        // --- Generate Nested Classes FIRST ---
        foreach (var nestedClass in classDef.NestedClasses)
        {
            // Skip duplicate definitions (check should ideally use FullName)
            if (generatedFullNames.Contains(nestedClass.FullName))
                continue;

            // Add to tracked classes
            generatedFullNames.Add(nestedClass.FullName);

            // Generate the nested class recursively
            GenerateClassSourceRecursive(nestedClass, sb, indentLevel + 1, generatedFullNames);
            sb.AppendLine(); // Add a line break after nested class
        }
        // --- End Nested Classes ---

        // Add properties
        foreach (var property in classDef.Properties)
        {
            var propertyName = property.Name.TrimStart('@');
            var fullPropertyType = property.PropertyType;
            var propertyType = ConvertPropertyTypeSyntax(fullPropertyType);

            // Pass the full type name (which we already trimmed into propertyType) to binding logic
            GeneratePropertyBindingForProperty(property, propertyName, propertyType, sb, indentLevel);
        }

        // Generate recursive binding method
        if (classDef.Properties.Any())
        {
            GeneratePropertyBindingLogic(classDef, sb, indentLevel);
        }
        else
        {
            // Empty binding method just returns this
            sb.AppendLine($"{indent}    /// <summary>");
            sb.AppendLine($"{indent}    /// This object has no properties to bind");
            sb.AppendLine($"{indent}    /// </summary>");
            sb.AppendLine($"{indent}    public static {classDef.Name}? Bind(SaveObject? node)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        if (node == null) return null;");
            sb.AppendLine($"{indent}        return new {classDef.Name}(); // Return empty instance");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
        }

        // Close class
        sb.AppendLine($"{indent}}}");
    }

    // Helper to add nullable annotation '?' where appropriate
    private static string AddNullableAnnotation(string? typeName)
    {
        if (typeName == null) return "object?"; // Handle null case

        typeName = typeName.Trim();
        if (typeName.EndsWith("?")) // Already nullable
            return typeName;

        // Reference types always get '?' in nullable context
        if (typeName == "string" || typeName == "object" || typeName.Contains("<") || (!IsValueType(typeName) && typeName != "dynamic"))
            return typeName + "?";

        // Value types need '?' unless already Nullable<T>
        if (!typeName.StartsWith("System.Nullable<"))
            return typeName + "?";

        return typeName; // Already Nullable<T> or not applicable
    }

    // Helper to convert property type strings for use in Bind methods
    private static string ConvertPropertyTypeSyntax(string originalType)
    {
        // Trim nullable annotation '?' if present
        return originalType.TrimEnd('?');
    }

    // Helper to check if a type name is a reserved name 
    private static bool IsReservedTypeName(string name) => SimpleTypes.Contains(name);

    // Generate property binding logic based on property type
    private static void GeneratePropertyBindingLogic(ClassDefinition classDef, StringBuilder sb, int indentLevel)
    {
        string indent = new string(' ', indentLevel * 4);

        sb.AppendLine();
        sb.AppendLine($"{indent}    /// <summary>");
        sb.AppendLine($"{indent}    /// Binds a SaveObject to a new {classDef.Name} instance.");
        sb.AppendLine($"{indent}    /// </summary>");
        sb.AppendLine($"{indent}    /// <param name=\"obj\">The SaveObject to bind. Can be null.</param>");
        sb.AppendLine($"{indent}    /// <returns>A new {classDef.Name} instance or null if input is null.</returns>");
        sb.AppendLine($"{indent}    public static {classDef.Name}? Bind(SaveObject? obj)"); // Nullable return
        sb.AppendLine($"{indent}    {{");
        sb.AppendLine($"{indent}        if (obj == null) return null;"); // Handle null input
        sb.AppendLine();
        sb.AppendLine($"{indent}        var model = new {classDef.Name}();");
        sb.AppendLine();

        // Generate binding logic for each property
        foreach (var property in classDef.Properties)
        {
            var propertyName = property.Name.TrimStart('@');
            var fullPropertyType = property.PropertyType;
            var propertyType = ConvertPropertyTypeSyntax(fullPropertyType);

            // Pass the full type name (which we already trimmed into propertyType) to binding logic
            GeneratePropertyBindingForProperty(property, propertyName, propertyType, sb, indentLevel);
        }

        sb.AppendLine();
        sb.AppendLine($"{indent}        return model;");
        sb.AppendLine($"{indent}    }}"); // End of binder method
    }

    // Generate property binding logic based on property type
    private static void GeneratePropertyBindingForProperty(PropertyDefinition property, string propertyName, string propertyTypeSyntax, StringBuilder builder, int indentLevel)
    {
        string indent = new string(' ', indentLevel * 4);
        string originalKey = property.OriginalName;
        string varName = propertyName.ToLowerInvariant() + "Value"; // Base name for temporary variables

        // Determine the base type (non-nullable)
        string baseType = propertyTypeSyntax.TrimEnd('?');
        bool isNullable = propertyTypeSyntax.EndsWith("?");

        builder.AppendLine(indent + "            // Bind " + propertyName + " (" + propertyTypeSyntax + ") from key \"" + originalKey + "\"");

        // --- Handle PDX Dictionary Pattern ---
        if (property.IsPdxDictionaryPattern)
        {
            // Create a Dictionary and iterate through items in a PDX-style array of key-value pairs
            builder.AppendLine(indent + "            if (obj.TryGetSaveArray(\"" + originalKey + "\", out SaveArray " + varName + "Array) && " + varName + "Array != null)");
            builder.AppendLine(indent + "            {");
            builder.AppendLine(indent + "                var dict = new " + propertyTypeSyntax + "();");
            builder.AppendLine(indent + "                foreach (var arrayItem in " + varName + "Array.Items)");
            builder.AppendLine(indent + "                {");
            builder.AppendLine(indent + "                    // PDX pattern: each array item is another array with key/value pair");
            builder.AppendLine(indent + "                    if (arrayItem is SaveArray kvpArray && kvpArray.Items.Count >= 2)");
            builder.AppendLine(indent + "                    {");
            builder.AppendLine(indent + "                        // Get key and value parts");
            builder.AppendLine(indent + "                        var keyPart = kvpArray.Items[0];");
            builder.AppendLine(indent + "                        var valuePart = kvpArray.Items[1];");

            // Detect the key and value types from the dictionary type
            // Dictionary<TKey, TValue>
            var match = Regex.Match(baseType, @"Dictionary<(?<keyType>[^,]+),\s*(?<valueType>.+)>");
            if (match.Success)
            {
                var keyType = match.Groups["keyType"].Value.Trim();
                var valueType = match.Groups["valueType"].Value.Trim();
                bool isComplexValue = !IsSimpleType(valueType);

                // Key conversion logic - common key types
                if (keyType == "int" || keyType == "long")
                {
                    builder.AppendLine(indent + "                        if (keyPart is Scalar<" + keyType + "> keyScalar)");
                    builder.AppendLine(indent + "                        {");
                    builder.AppendLine(indent + "                            " + keyType + " key = keyScalar.Value;");
                }
                else if (keyType == "string")
                {
                    builder.AppendLine(indent + "                        if (keyPart is Scalar<string> keyScalar)");
                    builder.AppendLine(indent + "                        {");
                    builder.AppendLine(indent + "                            string key = keyScalar.Value;");
                }
                else
                {
                    // Unknown key type, assume string representation
                    builder.AppendLine(indent + "                        if (keyPart is ISaveValue keyValue)");
                    builder.AppendLine(indent + "                        {");
                    builder.AppendLine(indent + "                            " + keyType + " key = keyValue.ToString();");
                }

                // Value conversion logic
                if (isComplexValue)
                {
                    // For complex object values
                    builder.AppendLine(indent + "                            if (valuePart is SaveObject valueObj)");
                    builder.AppendLine(indent + "                            {");
                    builder.AppendLine(indent + "                                var value = " + valueType + ".Bind(valueObj);");
                    builder.AppendLine(indent + "                                if (value != null)");
                    builder.AppendLine(indent + "                                {");
                    builder.AppendLine(indent + "                                    dict[key] = value;");
                    builder.AppendLine(indent + "                                }");
                    builder.AppendLine(indent + "                            }");
                }
                else
                {
                    // For scalar values
                    string scalarValueType = GetScalarTypeForElementType(valueType);
                    builder.AppendLine(indent + "                            if (valuePart is Scalar<" + scalarValueType + "> valueScalar)");
                    builder.AppendLine(indent + "                            {");
                    builder.AppendLine(indent + "                                dict[key] = valueScalar.Value;");
                    builder.AppendLine(indent + "                            }");
                }

                builder.AppendLine(indent + "                        }");
            }
            else
            {
                builder.AppendLine(indent + "                        // Could not detect dictionary types, using string keys and values");
                builder.AppendLine(indent + "                        if (keyPart != null && valuePart != null)");
                builder.AppendLine(indent + "                        {");
                builder.AppendLine(indent + "                            string key = keyPart.ToString();");
                builder.AppendLine(indent + "                            string value = valuePart.ToString();");
                builder.AppendLine(indent + "                            dict[key] = value;");
                builder.AppendLine(indent + "                        }");
            }

            builder.AppendLine(indent + "                    }");
            builder.AppendLine(indent + "                }");
            builder.AppendLine(indent + "                model." + propertyName + " = dict;");
            builder.AppendLine(indent + "            }");
        }
        // --- Handle standard Dictionaries ---
        else if (property.IsDictionary)
        {
            builder.AppendLine(indent + "            // Standard dictionary: each property becomes a key-value pair");
            builder.AppendLine(indent + "            if (obj.TryGetSaveObject(\"" + originalKey + "\", out SaveObject " + varName + "Obj) && " + varName + "Obj != null)");
            builder.AppendLine(indent + "            {");
            builder.AppendLine(indent + "                var dict = new " + propertyTypeSyntax + "();");

            // Detect the key and value types from the dictionary type
            // Dictionary<TKey, TValue>
            var match = Regex.Match(baseType, @"Dictionary<(?<keyType>[^,]+),\s*(?<valueType>.+)>");
            if (match.Success)
            {
                var keyType = match.Groups["keyType"].Value.Trim();
                var valueType = match.Groups["valueType"].Value.Trim();
                bool isComplexValue = !IsSimpleType(valueType);

                builder.AppendLine(indent + "                // Process each property as a key-value pair");
                builder.AppendLine(indent + "                foreach (var kvp in " + varName + "Obj.Properties)");
                builder.AppendLine(indent + "                {");

                // Key conversion logic - common key types
                if (keyType == "int")
                {
                    builder.AppendLine(indent + "                    if (int.TryParse(kvp.Key, out int key))");
                    builder.AppendLine(indent + "                    {");
                }
                else if (keyType == "long")
                {
                    builder.AppendLine(indent + "                    if (long.TryParse(kvp.Key, out long key))");
                    builder.AppendLine(indent + "                    {");
                }
                else if (keyType == "string")
                {
                    builder.AppendLine(indent + "                    {");
                    builder.AppendLine(indent + "                        string key = kvp.Key;");
                }
                else
                {
                    // Try to convert the string to the key type if needed
                    builder.AppendLine(indent + "                    {");
                    builder.AppendLine(indent + "                        " + keyType + " key = kvp.Key; // May need to be converted");
                }

                // Value conversion logic
                if (isComplexValue)
                {
                    // For complex object values
                    builder.AppendLine(indent + "                        if (kvp.Value is SaveObject valueObj)");
                    builder.AppendLine(indent + "                        {");
                    builder.AppendLine(indent + "                            var value = " + valueType + ".Bind(valueObj);");
                    builder.AppendLine(indent + "                            if (value != null)");
                    builder.AppendLine(indent + "                            {");
                    builder.AppendLine(indent + "                                dict[key] = value;");
                    builder.AppendLine(indent + "                            }");
                    builder.AppendLine(indent + "                        }");
                }
                else
                {
                    // For scalar values
                    string scalarValueType = GetScalarTypeForElementType(valueType);
                    builder.AppendLine(indent + "                        if (kvp.Value is Scalar<" + scalarValueType + "> valueScalar)");
                    builder.AppendLine(indent + "                        {");
                    builder.AppendLine(indent + "                            dict[key] = valueScalar.Value;");
                    builder.AppendLine(indent + "                        }");
                }

                builder.AppendLine(indent + "                    }");
            }
            else
            {
                // Could not determine types, assume string,string
                builder.AppendLine(indent + "                foreach (var kvp in " + varName + "Obj.Properties)");
                builder.AppendLine(indent + "                {");
                builder.AppendLine(indent + "                    string key = kvp.Key;");
                builder.AppendLine(indent + "                    string value = kvp.Value?.ToString() ?? \"\";");
                builder.AppendLine(indent + "                    dict[key] = value;");
                builder.AppendLine(indent + "                }");
            }

            builder.AppendLine(indent + "                }");
            builder.AppendLine(indent + "                model." + propertyName + " = dict;");
            builder.AppendLine(indent + "            }");
        }
        // --- Handle List<T> ---
        else if (property.IsCollection)
        {
            var listMatch = Regex.Match(baseType, @"List<(?<itemType>.*)>");
            if (listMatch.Success)
            {
                var itemType = listMatch.Groups["itemType"].Value; // Includes ? 
                bool isComplexItem = !IsSimpleType(itemType.TrimEnd('?'));

                builder.AppendLine(indent + "            if (obj.TryGetSaveArray(\"" + originalKey + "\", out SaveArray " + varName + "Array) && " + varName + "Array != null)");
                builder.AppendLine(indent + "            {");
                builder.AppendLine(indent + "                var list = new " + propertyTypeSyntax + "();");
                builder.AppendLine(indent + "                foreach (var item in " + varName + "Array.Items)");
                builder.AppendLine(indent + "                {");
                if (isComplexItem)
                {
                    // Use explicit SaveObject type instead of var
                    builder.AppendLine(indent + "                    SaveObject itemObj = item as SaveObject;");
                    builder.AppendLine(indent + "                    " + itemType.TrimEnd('?') + "? boundItem = " + itemType.TrimEnd('?') + ".Bind(itemObj);");
                    builder.AppendLine(indent + "                    list.Add(boundItem);");
                }
                else
                {
                    string scalarType = GetScalarTypeForElementType(itemType.TrimEnd('?'));
                    builder.AppendLine(indent + "                    if (item is Scalar<" + scalarType + "> scalar && scalar != null)");
                    builder.AppendLine(indent + "                    {");
                    builder.AppendLine(indent + "                        list.Add(scalar.Value);");
                    builder.AppendLine(indent + "                    }");
                    builder.AppendLine(indent + "                    else { list.Add(null); } // Add null for non-scalar or null items in scalar list");
                }
                builder.AppendLine(indent + "                }"); // end foreach item
                builder.AppendLine(indent + "                model." + propertyName + " = list;");
                builder.AppendLine(indent + "            }");
            }
            else
            {
                builder.AppendLine(indent + "            // WARN: Could not parse list item type from '" + propertyTypeSyntax + "' for key \"" + originalKey + "\"");
            }
        }
        // --- Handle Complex Nested Object (T) ---
        else if (!IsSimpleType(baseType))
        {
            builder.AppendLine(indent + "            if (obj.TryGetSaveObject(\"" + originalKey + "\", out SaveObject " + varName + "Obj))");
            builder.AppendLine(indent + "            {");
            builder.AppendLine(indent + "                model." + propertyName + " = " + baseType + ".Bind(" + varName + "Obj);");
            builder.AppendLine(indent + "            }");
        }
        // --- Handle Simple Scalar Properties ---
        else
        {
            string tryGetMethod = baseType switch
            {
                "int" => "TryGetInt",
                "long" => "TryGetLong",
                "float" => "TryGetFloat",
                "bool" => "TryGetBool",
                "DateTime" => "TryGetDateTime",
                "Guid" => "TryGetGuid",
                "string" => "TryGetString",
                _ => null
            };

            if (tryGetMethod != null)
            {
                string defaultValue = "null"; // Default to null for nullable types
                if (baseType == "string")
                {
                    builder.AppendLine(indent + "            model." + propertyName + " = obj.TryGetString(\"" + originalKey + "\", out string " + varName + ") && " + varName + " != \"none\" ? " + varName + " : " + defaultValue + ";");
                }
                else
                {
                    // Use explicit type for the out variable instead of var
                    string outVarType = baseType;
                    if (IsValueType(baseType))
                        outVarType += "?";

                    builder.AppendLine(indent + "            if (obj." + tryGetMethod + "(\"" + originalKey + "\", out " + outVarType + " " + varName + "))");
                    builder.AppendLine(indent + "                model." + propertyName + " = " + varName + ";");
                    // Property remains null if TryGet fails
                }
            }
            else
            {
                builder.AppendLine(indent + "            // WARN: Cannot bind unknown simple type '" + propertyTypeSyntax + "' for key \"" + originalKey + "\"");
            }
        }

        builder.AppendLine();
    }

    // Helper to get the underlying C# type for Scalar<T>
    private static string GetScalarTypeForElementType(string elementType)
    {
        // elementType should already be the C# type name (e.g., "int", "float", "DateTime")
        return elementType switch
        {
            "int" => "int", // System.Int32
            "long" => "long", // System.Int64
            "float" => "float", // System.Single
            "double" => "double", // System.Double
            "bool" => "bool", // System.Boolean
            "string" => "string", // System.String
            "DateTime" => "System.DateTime", // Need namespace if not globally using
            "Guid" => "System.Guid", // Need namespace if not globally using
            _ => elementType // Assume it's a type name that works directly (like a custom struct)
        };
    }

    // Helper to check if a type is a simple type
    private static bool IsSimpleType(string? typeName) =>
        typeName != null && SimpleTypes.Contains(typeName.TrimEnd('?'));

    // Helper to check if a type name represents a value type (primitive or struct)
    // Needed for the AddNullableAnnotation helper
    private static bool IsValueType(string? typeName)
    {
        if (string.IsNullOrEmpty(typeName)) return false;
        string baseTypeName = typeName.TrimEnd('?'); // Check the base type

        // Basic check for known value types 
        var knownValueTypes = new HashSet<string>(StringComparer.OrdinalIgnoreCase) {
            "int", "long", "float", "double", "bool", "DateTime", "Guid",
            "System.Int32", "System.Int64", "System.Single", "System.Double",
            "System.Boolean", "System.DateTime", "System.Guid"
        };

        if (knownValueTypes.Contains(baseTypeName)) return true;

        // Simple struct heuristic: Starts with Upper, not generic, not known reference type
        return !baseTypeName.Contains("<") &&
               !SimpleTypes.Contains(baseTypeName) && // Exclude known simple reference types like string
               baseTypeName != "object" &&
               baseTypeName != "dynamic" &&
               baseTypeName.Length > 0 &&
               char.IsUpper(baseTypeName[0]);
    }

    /// <summary>
    /// Generates models for a class marked with GameStateDocumentAttribute
    /// </summary>
    public static void GeneratePartialClass(SourceProductionContext context, AttributedClass attributedClass, AdditionalText schemaFile, IEnumerable<SaveObjectAnalysis> analyses)
    {
        try
        {
            // Verify we have analyses to work with
            var analysisList = analyses?.ToList() ?? new List<SaveObjectAnalysis>();
            if (!analysisList.Any())
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor("PDXSG301", "No Analysis Results",
                        $"No analysis results for class {attributedClass.ClassName} from schema file {Path.GetFileName(schemaFile.Path)}",
                        "StellarisModelsGenerator", DiagnosticSeverity.Warning, true),
                    Location.None));
                return;
            }

            // Prepare StringBuilder for the partial class content
            var fileContentBuilder = new StringBuilder();

            // Add standard usings and attribute definitions
            fileContentBuilder.AppendLine("// <auto-generated/>");
            fileContentBuilder.AppendLine("#nullable enable");
            fileContentBuilder.AppendLine("using System;");
            fileContentBuilder.AppendLine("using System.Collections.Generic;");
            fileContentBuilder.AppendLine("using System.Linq;");
            fileContentBuilder.AppendLine("using System.Globalization;");
            fileContentBuilder.AppendLine("using MageeSoft.PDX.CE;");
            fileContentBuilder.AppendLine();

            // Add the namespace block
            fileContentBuilder.AppendLine($"namespace {attributedClass.Namespace}");
            fileContentBuilder.AppendLine("{");

            // Add the partial class declaration
            fileContentBuilder.AppendLine($"    // Generated from schema file: {Path.GetFileName(schemaFile.Path)}");
            fileContentBuilder.AppendLine($"    public partial class {attributedClass.ClassName}");
            fileContentBuilder.AppendLine("    {");

            // Track nested class definitions to avoid duplicates
            HashSet<string> generatedFullNames = new HashSet<string>();

            // Process and generate nested classes first
            foreach (var analysis in analysisList)
            {
                foreach (var classDef in analysis.ClassDefinitions.Values
                    .Where(c => c != null && c.Name != attributedClass.ClassName)) // Ensure classDef is not null
                {
                    // Skip null/empty class names
                    if (string.IsNullOrEmpty(classDef?.Name))
                        continue;

                    // Skip primitive types and C# reserved names
                    if (IsReservedTypeName(classDef.Name))
                        continue;

                    // Check if we've already generated this class to avoid duplicates
                    string fullClassName = classDef.FullName;
                    if (generatedFullNames.Contains(fullClassName))
                        continue;

                    GenerateNestedClass(classDef, fileContentBuilder, 2, generatedFullNames); // Indent level 2 for nesting
                    generatedFullNames.Add(fullClassName);
                }
            }

            // Add SourceObject property to the main partial class
            fileContentBuilder.AppendLine();
            fileContentBuilder.AppendLine("        /// <summary>");
            fileContentBuilder.AppendLine("        /// Gets the original SaveObject this instance was bound from.");
            fileContentBuilder.AppendLine("        /// </summary>");
            fileContentBuilder.AppendLine("        public SaveObject? SourceObject { get; private set; }");

            // Add properties from the schema for the MAIN partial class
            var mainClassDef = analysisList
                .SelectMany(a => a.ClassDefinitions.Values)
                .FirstOrDefault(c => c != null && c.Name == attributedClass.ClassName);

            if (mainClassDef?.Properties != null)
            {
                foreach (var property in mainClassDef.Properties)
                {
                    var propertyName = property.Name.TrimStart('@');

                    // Handle name conflict for the property declaration
                    if (propertyName == attributedClass.ClassName)
                    {
                        propertyName += "Value";
                    }

                    var propertyType = AddNullableAnnotation(property.PropertyType);

                    fileContentBuilder.AppendLine();
                    fileContentBuilder.AppendLine($"        /// <summary>");
                    fileContentBuilder.AppendLine($"        /// Property for '{property.OriginalName}'");
                    fileContentBuilder.AppendLine($"        /// </summary>");
                    fileContentBuilder.AppendLine($"        public {propertyType} {propertyName} {{ get; set; }}");
                }
            }

            // Add the Bind method for the MAIN partial class
            GenerateBindMethodForPartialClass(fileContentBuilder, attributedClass.ClassName, mainClassDef);

            // Close the partial class
            fileContentBuilder.AppendLine("    }");

            // Close namespace
            fileContentBuilder.AppendLine("}");
            fileContentBuilder.AppendLine(); // Trailing newline

            // Add the source file
            string fileName = $"{attributedClass.ClassName}.g.cs";
            context.AddSource(fileName, SourceText.From(fileContentBuilder.ToString(), Encoding.UTF8));

            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor("PDXSG302", "Generated Partial Class",
                    $"Generated partial class {attributedClass.ClassName} in file {fileName} with {generatedFullNames.Count} nested classes.",
                    "StellarisModelsGenerator", DiagnosticSeverity.Info, true),
                Location.None));
        }
        catch (Exception ex)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor("PDXSG303", "Generator Exception",
                    $"Generator failed for partial class {attributedClass.ClassName}: {ex.GetType().Name} - {ex.Message}",
                    "StellarisModelsGenerator", DiagnosticSeverity.Error, true),
                Location.None));
        }
    }

    // New method specifically for the main partial class Bind logic
    private static void GenerateBindMethodForPartialClass(StringBuilder sb, string className, ClassDefinition? classDef)
    {
        sb.AppendLine();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Binds a SaveObject to a new instance of this partial class.");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        /// <param name=\"obj\">The SaveObject to bind. Can be null.</param>");
        sb.AppendLine("        /// <returns>A new instance or null if input is null.</returns>");
        sb.AppendLine("        public static " + className + "? Bind(SaveObject? obj)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (obj == null) return null;");
        sb.AppendLine();
        sb.AppendLine("            " + className + " model = new " + className + "();");
        sb.AppendLine("            model.SourceObject = obj; // Store reference to source object");
        sb.AppendLine();

        // Generate binding code for each property
        if (classDef?.Properties != null)
        {
            foreach (var property in classDef.Properties)
            {
                var propertyName = property.Name.TrimStart('@');
                var originalName = property.OriginalName;
                var bindVariableNameBase = propertyName.ToLowerInvariant(); // Base for unique names

                // Handle potential name conflict in assignment
                if (propertyName == className)
                {
                    propertyName += "Value";
                }

                var baseType = property.PropertyType.TrimEnd('?');

                if (SimpleTypes.Contains(baseType))
                {
                    string? tryGetMethod = GetTryGetMethodName(baseType);
                    
                    if (tryGetMethod != null)
                    {
                        if (baseType == "string")
                        {
                            string varString = bindVariableNameBase + "StringValue";
                            sb.AppendLine("            model." + propertyName + " = obj.TryGetString(\"" + originalName + "\", out string " + varString + ") && " + varString + " != \"none\" ? " + varString + " : null;");
                        }
                        else
                        {
                            string varValue = bindVariableNameBase + "Value";
                            sb.AppendLine("            if (obj." + tryGetMethod + "(\"" + originalName + "\", out " + baseType + " " + varValue + "))");
                            sb.AppendLine("                model." + propertyName + " = " + varValue + ";");
                        }
                    }
                }
                else if (baseType.StartsWith("List<") || baseType.StartsWith("Dictionary<"))
                {
                    sb.AppendLine("            // TODO: Bind complex type: " + propertyName + " (" + baseType + ")");

                    if (baseType.StartsWith("List<"))
                    {
                        string varArray = bindVariableNameBase + "Array";
                        sb.AppendLine("            if (obj.TryGetSaveArray(\"" + originalName + "\", out SaveArray " + varArray + ") && " + varArray + " != null)");
                        sb.AppendLine("                model." + propertyName + " = new " + property.PropertyType + "(); // Initialize empty list");

                        // Check what type of list this is
                        var listMatch = Regex.Match(baseType, @"List<(?<itemType>.+)>");
                        if (listMatch.Success)
                        {
                            var itemType = listMatch.Groups["itemType"].Value.TrimEnd('?');

                            // If this is a list of scalar types, populate it
                            if (SimpleTypes.Contains(itemType))
                            {
                                sb.AppendLine("                // Populate list from array of scalar values");
                                sb.AppendLine("                if (" + varArray + " != null)");
                                sb.AppendLine("                {");
                                sb.AppendLine("                    foreach (var item in " + varArray + ".Items)");
                                sb.AppendLine("                    {");
                                sb.AppendLine("                        if (item is Scalar<" + itemType + "> scalarValue)");
                                sb.AppendLine("                        {");
                                sb.AppendLine("                            model." + propertyName + ".Add(scalarValue.Value);");
                                sb.AppendLine("                        }");
                                sb.AppendLine("                    }");
                                sb.AppendLine("                }");
                            }
                        }
                    }
                    else
                    { // Dictionary
                        string varDictObj = bindVariableNameBase + "DictObj";
                        sb.AppendLine("            if (obj.TryGetSaveObject(\"" + originalName + "\", out SaveObject " + varDictObj + ") && " + varDictObj + " != null)");
                        sb.AppendLine("                model." + propertyName + " = new " + property.PropertyType + "(); // Initialize empty dictionary");
                    }
                }
                else // Assume nested object
                {
                    string varNestedObj = bindVariableNameBase + "NestedObj";
                    sb.AppendLine("            if (obj.TryGetSaveObject(\"" + originalName + "\", out SaveObject " + varNestedObj + "))");
                    sb.AppendLine("                model." + propertyName + " = " + baseType + ".Bind(" + varNestedObj + ");");
                }
                sb.AppendLine(); // Add blank line after each property block
            }
        }

        sb.AppendLine();
        sb.AppendLine("            return model;");
        sb.AppendLine("        }");
    }

    // Renamed from GenerateSimplifiedBindMethod
    private static string? GetTryGetMethodName(string baseType)
    {
        return baseType switch
        {
            "int" => "TryGetInt",
            "long" => "TryGetLong",
            "float" => "TryGetFloat",
            "bool" => "TryGetBool",
            "DateTime" => "TryGetDateTime",
            "Guid" => "TryGetGuid",
            "string" => "TryGetString",
            _ => null
        };
    }

    // Generate a simplified nested class 
    private static void GenerateNestedClass(ClassDefinition classDef, StringBuilder sb, int indentLevel, HashSet<string> generatedFullNames)
    {
        string indent = new string(' ', indentLevel * 4);

        sb.AppendLine($"{indent}/// <summary>");
        if (!string.IsNullOrEmpty(classDef.OriginalPath)) { sb.AppendLine($"{indent}/// Generated from PDX save path: {classDef.OriginalPath}"); }
        sb.AppendLine($"{indent}/// </summary>");
        sb.AppendLine($"{indent}public class {classDef.Name}");
        sb.AppendLine($"{indent}{{");

        // Nested classes first
        foreach (var nestedClass in classDef.NestedClasses)
        {
            if (!generatedFullNames.Contains(nestedClass.FullName))
            {
                generatedFullNames.Add(nestedClass.FullName);
                GenerateNestedClass(nestedClass, sb, indentLevel + 1, generatedFullNames);
            }
        }

        // Properties
        foreach (var property in classDef.Properties)
        {
            var propertyName = property.Name.TrimStart('@');
            if (propertyName == classDef.Name) { propertyName += "Value"; } // Avoid name conflict
            var propertyType = AddNullableAnnotation(property.PropertyType);
            sb.AppendLine($"{indent}    /// <summary>Property for '{property.OriginalName}'</summary>");
            sb.AppendLine($"{indent}    public {propertyType} {propertyName} {{ get; set; }}");
            sb.AppendLine();
        }

        // Source object property
        sb.AppendLine($"{indent}    /// <summary>The source SaveObject this instance was bound from</summary>");
        sb.AppendLine($"{indent}    public SaveObject? SourceObject {{ get; private set; }}");
        sb.AppendLine();

        // Bind method
        sb.AppendLine($"{indent}    /// <summary>Binds a SaveObject to a new instance</summary>");
        sb.AppendLine($"{indent}    public static {classDef.Name}? Bind(SaveObject? obj)");
        sb.AppendLine($"{indent}    {{");
        sb.AppendLine($"{indent}        if (obj == null) return null;");
        sb.AppendLine($"{indent}        {classDef.Name} model = new {classDef.Name}();");
        sb.AppendLine($"{indent}        model.SourceObject = obj;");
        sb.AppendLine();

        // Simple binding code
        foreach (var property in classDef.Properties)
        {
            var propertyName = property.Name.TrimStart('@');
            var originalName = property.OriginalName;
            var bindVariableNameBase = propertyName.ToLowerInvariant(); // Base for unique names

            if (propertyName == classDef.Name) { propertyName += "Value"; } // Use renamed property
            var baseType = property.PropertyType.TrimEnd('?');

            if (SimpleTypes.Contains(baseType))
            {
                string tryGetMethod = GetTryGetMethodName(baseType);
                if (tryGetMethod != null)
                {
                    if (baseType == "string")
                    {
                        string varString = bindVariableNameBase + "StringValue";
                        sb.AppendLine($"{indent}        model.{propertyName} = obj.TryGetString(\"{originalName}\", out string {varString}) && {varString} != \"none\" ? {varString} : null;");
                    }
                    else
                    {
                        string varValue = bindVariableNameBase + "Value";
                        sb.AppendLine($"{indent}        if (obj.{tryGetMethod}(\"{originalName}\", out {baseType} {varValue}) && {varValue} != null)");
                        sb.AppendLine($"{indent}            model.{propertyName} = {varValue};");
                    }
                }
            }
            else if (baseType.StartsWith("List<") || baseType.StartsWith("Dictionary<"))
            {
                sb.AppendLine($"{indent}        // TODO: Bind complex type: {propertyName} ({baseType})");
                if (baseType.StartsWith("List<"))
                {
                    string varArray = bindVariableNameBase + "Array";
                    sb.AppendLine($"{indent}        if (obj.TryGetSaveArray(\"{originalName}\", out SaveArray {varArray}) && {varArray} != null)");
                    sb.AppendLine($"{indent}            model." + propertyName + " = new " + property.PropertyType + "(); // Initialize empty list");

                    // Check what type of list this is
                    var listMatch = Regex.Match(baseType, @"List<(?<itemType>.+)>");
                    if (listMatch.Success)
                    {
                        var itemType = listMatch.Groups["itemType"].Value.TrimEnd('?');

                        // If this is a list of scalar types, populate it
                        if (SimpleTypes.Contains(itemType))
                        {
                            sb.AppendLine("                // Populate list from array of scalar values");
                            sb.AppendLine("                if (" + varArray + " != null)");
                            sb.AppendLine("                {");
                            sb.AppendLine("                    foreach (var item in " + varArray + ".Items)");
                            sb.AppendLine("                    {");
                            sb.AppendLine("                        if (item is Scalar<" + itemType + "> scalarValue)");
                            sb.AppendLine("                        {");
                            sb.AppendLine("                            model." + propertyName + ".Add(scalarValue.Value);");
                            sb.AppendLine("                        }");
                            sb.AppendLine("                    }");
                            sb.AppendLine("                }");
                        }
                    }
                }
                else
                {
                    string varDictObj = bindVariableNameBase + "DictObj";
                    sb.AppendLine($"{indent}        if (obj.TryGetSaveObject(\"{originalName}\", out SaveObject {varDictObj}) && " + varDictObj + " != null)");
                    sb.AppendLine($"{indent}            model." + propertyName + " = new " + property.PropertyType + "(); // Initialize empty dictionary");
                }
            }
            else
            { 
                // Assume nested object
                string varNestedObj = bindVariableNameBase + "NestedObj";
                sb.AppendLine($"{indent}        if (obj.TryGetSaveObject(\"{originalName}\", out SaveObject " + varNestedObj + "))");
                sb.AppendLine($"{indent}            model." + propertyName + " = " + baseType + ".Bind(" + varNestedObj + ");");
            }

            sb.AppendLine(); // Add blank line after each property block
        }

        sb.AppendLine();
        sb.AppendLine($"{indent}        return model;");
        sb.AppendLine($"{indent}    }}");

        sb.AppendLine($"{indent}}}"); // Close class
    }
}



