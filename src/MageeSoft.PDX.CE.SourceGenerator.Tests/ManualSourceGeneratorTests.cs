using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Collections.Immutable;
using System.Threading.Tasks;
using System.Linq;
using System.Reflection;
using System.IO;

namespace MageeSoft.PDX.CE.SourceGenerator.Tests;

[TestClass]
public class ManualSourceGeneratorTests
{
    public TestContext TestContext { get; set; }

    [TestMethod]
    public void SimpleKeyValues()
    { 
        // Arrange 
        var csfText = """
        one_identifier=value_as_identifier
        two_string="value_as_string"
        three_date="2100.01.02"
        four_bool_true=yes
        five_bool_false=no        
        """;

        // Create a file path that will be used consistently
        var schemaFileName = "model.csf";
        var absoluteSchemaFilePath = Path.GetFullPath(schemaFileName);
        
        var generator = new IncrementalGenerator();   
        var configOptions = new TestAnalyzerConfigOptions(new Dictionary<string, string>
        {
            { "build_property.PDXGenerateModels", "true" }
        });

        GeneratorDriver driver = CSharpGeneratorDriver.Create(
            generators: [generator.AsSourceGenerator()],
            additionalTexts: [new TestAdditionalFile(absoluteSchemaFilePath, csfText)],
            optionsProvider: new TestAnalyzerConfigOptionsProvider(configOptions),
            parseOptions: new CSharpParseOptions(LanguageVersion.Latest)
        );     

        // Using a simpler syntax to ensure the attribute argument is picked up
        var modelTestClass = """
using MageeSoft.PDX.CE;

namespace MageeSoft.PDX.CE.SourceGenerator.Tests
{
    [GameStateDocument("model.csf")] 
    public partial class Model 
    {
    
    }
}
""";

        var compilation = CSharpCompilation.Create(
             assemblyName: nameof(ManualSourceGeneratorTests),
            syntaxTrees: [
                CSharpSyntaxTree.ParseText(modelTestClass),
            ],
            references: [
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(GameStateDocumentAttribute).Assembly.Location)
            ],
            options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary)
        );

        driver.RunGeneratorsAndUpdateCompilation(compilation, out var newCompilation, out _);

        // Output the generated code
        foreach (var tree in newCompilation.SyntaxTrees)
        {
            TestContext.WriteLine(tree.ToString());
        }
        
        // Verify the generated model
        // Find the generated Model class syntax tree (look for auto-generated marker and specific content)
        var modelTree = newCompilation.SyntaxTrees
            .FirstOrDefault(tree => 
                tree.ToString().Contains("// <auto-generated/>") && 
                tree.ToString().Contains("partial class Model") &&
                tree.ToString().Contains("Bind("));
                
        // Alternatively, a more precise approach to find the generated file:
        var alternativeModelTree = newCompilation.SyntaxTrees
            .FirstOrDefault(tree => 
                (tree.FilePath.Contains("Model.g.cs") || // Check for typical generated file name patterns
                 tree.FilePath.Contains(".generated.") ||
                 tree.FilePath.EndsWith(".Generated.cs")) && 
                tree.ToString().Contains("partial class Model"));
        
        // Use the alternativeModelTree approach if modelTree isn't found
        if (modelTree == null && alternativeModelTree != null)
        {
            TestContext.WriteLine("Found model using alternative approach based on file path patterns");
            modelTree = alternativeModelTree;
        }
            
        Assert.IsNotNull(modelTree, "Generated Model class not found");
        
        // Output path information for debugging
        TestContext.WriteLine($"Found generated model at: {modelTree.FilePath}");        
        
        // Parse the tree to find members
        var root = modelTree.GetRoot();
        var modelClass = root.DescendantNodes()
            .OfType<ClassDeclarationSyntax>()
            .FirstOrDefault(c => c.Identifier.ValueText == "Model");
            
        Assert.IsNotNull(modelClass, "Model class declaration not found");
        
        // Verify expected properties exist
        var properties = modelClass.DescendantNodes().OfType<PropertyDeclarationSyntax>().ToList();
        
        // Check specific property existence
        Assert.IsTrue(properties.Any(p => p.Identifier.ValueText == "OneIdentifier"), "OneIdentifier property not found");
        Assert.IsTrue(properties.Any(p => p.Identifier.ValueText == "TwoString"), "TwoString property not found");
        Assert.IsTrue(properties.Any(p => p.Identifier.ValueText == "ThreeDate"), "ThreeDate property not found");
        Assert.IsTrue(properties.Any(p => p.Identifier.ValueText == "FourBoolTrue"), "FourBoolTrue property not found");
        Assert.IsTrue(properties.Any(p => p.Identifier.ValueText == "FiveBoolFalse"), "FiveBoolFalse property not found");
        
        // Verify Bind method exists
        var bindMethod = modelClass.DescendantNodes()
            .OfType<MethodDeclarationSyntax>()
            .FirstOrDefault(m => m.Identifier.ValueText == "Bind");
            
        Assert.IsNotNull(bindMethod, "Bind method not found");
        Assert.IsTrue(bindMethod.ParameterList.Parameters.Count == 1, "Bind method should have one parameter");
        Assert.IsTrue(bindMethod.ParameterList.Parameters[0].Type.ToString().Contains("SaveObject"), "Bind parameter should be SaveObject");
    }
}